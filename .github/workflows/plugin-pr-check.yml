name: Validate & Enforce Plugin Ownership

permissions:
  contents: write
  pull-requests: write

on:
  pull_request:
    types:
      - opened
      - edited
      - synchronize
      - ready_for_review
    paths:
      - 'plugins/**'
      - '.github/workflows/publish-plugins.yml'

jobs:
  draft-notice:
    if: ${{ github.event.pull_request.draft == true }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Authenticate GH CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh auth status

      - name: Post draft notice
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          COMMENT="<!--PLUGIN_VALIDATION_DRAFT_NOTICE-->"
          COMMENT+=$'\n'"‚ö†Ô∏è This PR is currently a draft. Plugin validation will run once the PR is marked ready for review."
          EXISTING_COMMENT_ID=$(gh pr view $PR_NUMBER --json comments --jq '.comments[] | select(.author.login=="github-actions[bot]") | select(.body | contains("<!--PLUGIN_VALIDATION_DRAFT_NOTICE-->")) | .id')
          if [ -n "$EXISTING_COMMENT_ID" ]; then
            gh pr comment edit $EXISTING_COMMENT_ID --body "$COMMENT"
          else
            gh pr comment $PR_NUMBER --body "$COMMENT"
          fi

  validate-and-comment:
    runs-on: ubuntu-latest
    steps:
      - name: Fail if PR is draft
        if: ${{ github.event.pull_request.draft == true }}
        run: |
          echo "‚ùå PR is a draft ‚Äî validation cannot run on draft PRs"
          exit 1

      - name: Checkout PR with full history
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Fetch base branch fully
        run: git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/base

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Authenticate GH CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh auth status

      - name: Validate plugin(s) and build PR comment
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          COMMENT="<!--PLUGIN_VALIDATION_COMMENT-->"
          COMMENT+=$'\n'
          # Table header and row placeholders (will be filled per plugin)
          TABLE_HEADER=""
          TABLE_ROW=""
          COMMENT+=$'\n'  # Space before table
          COMMENT+=$'\n'"### Plugin Validation Results"
          COMMENT+=$'\n'

          FAILED=0
          PR_AUTHOR="${{ github.actor }}"
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2)

          # Check if PR author is a repository maintainer (has write or admin access)
          IS_REPO_MAINTAINER=0
          PERMISSION=$(gh api repos/$REPO_OWNER/$REPO_NAME/collaborators/$PR_AUTHOR/permission --jq .permission)
          if [[ "$PERMISSION" == "admin" || "$PERMISSION" == "write" ]]; then
            IS_REPO_MAINTAINER=1
          fi

          # Compute merge base relative to the fully fetched base branch
          MERGE_BASE=$(git merge-base origin/base HEAD)

          # Detect modified plugins relative to merge base
          PLUGIN_DIRS=$(git diff --name-only $MERGE_BASE HEAD \
            | grep '^plugins/' | cut -d '/' -f2 | sort -u | uniq)

          echo "Modified plugin directories detected: $PLUGIN_DIRS"

          # Enforce single plugin per PR
          PLUGIN_COUNT=$(echo "$PLUGIN_DIRS" | wc -l)
          if [ "$PLUGIN_COUNT" -ne 1 ]; then
            COMMENT+=$'\n'"‚ùå **Error:** PR must only modify one plugin. Detected $PLUGIN_COUNT plugins."
            FAILED=1
          fi

          for plugin in $PLUGIN_DIRS; do
            PLUGIN_JSON="plugins/$plugin/plugin.json"
            README="plugins/$plugin/README.md"
            COMMENT+=$'\n'"- **$plugin**:"
            PLUGIN_FAILED=0
            TABLE_HEADER=""
            TABLE_ROW=""

            # plugin.json check
            if [ ! -f "$PLUGIN_JSON" ]; then
              COMMENT+=$'\n'"  - ‚ùå plugin.json missing"
              PLUGIN_FAILED=1
            else
              COMMENT+=$'\n'"  - ‚úÖ plugin.json exists"
            fi

            # README check
            if [ ! -f "$README" ]; then
              COMMENT+=$'\n'"  - ‚ùå README.md missing"
              PLUGIN_FAILED=1
            else
              COMMENT+=$'\n'"  - ‚úÖ README.md exists"
            fi

            # JSON validation and owner/maintainers/version checks
            if [ -f "$PLUGIN_JSON" ]; then
              if ! cat "$PLUGIN_JSON" | node -e "try{JSON.parse(require('fs').readFileSync(0,'utf-8'));}catch(e){process.exit(1);}"; then
                COMMENT+=$'\n'"  - ‚ùå Invalid JSON"
                PLUGIN_FAILED=1
              else
                COMMENT+=$'\n'"  - ‚úÖ JSON valid"
                # Validate required properties
                REQUIRED_KEYS=(name version owner maintainers description)
                for req_key in "${REQUIRED_KEYS[@]}"; do
                  if ! jq -e ".[\"$req_key\"]" "$PLUGIN_JSON" >/dev/null; then
                    COMMENT+=$'\n'"  - ‚ùå Required property '$req_key' missing from $PLUGIN_JSON"
                    PLUGIN_FAILED=1
                  fi
                done
                # Build table header and row for plugin.json fields
                KEYS=($(jq -r 'keys_unsorted[]' "$PLUGIN_JSON"))
                TABLE_HEADER="|"
                TABLE_ROW="|"
                for key in "${KEYS[@]}"; do
                  TABLE_HEADER+=" $key |"
                  # If the value is an array of strings, join as comma-separated
                  value=$(jq -r \
                    ".[\"$key\"] | if type==\"array\" and (map(type) | all(. == \"string\")) then join(\", \") \
                    elif type==\"array\" or type==\"object\" then @json else . end" "$PLUGIN_JSON")
                  TABLE_ROW+=" $value |"
                done
                # Markdown separator row
                TABLE_SEPARATOR="|"
                for key in "${KEYS[@]}"; do
                  TABLE_SEPARATOR+="---|"
                done
              fi

              OWNER=$(jq -r '.owner' "$PLUGIN_JSON")
              MAINTAINERS=$(jq -r '[.maintainers[]?] | join(" ")' "$PLUGIN_JSON")
              MAINTAINERS="${MAINTAINERS:-}"

              if [[ "$PR_AUTHOR" != "$OWNER" ]] && [[ ! " $MAINTAINERS " =~ " $PR_AUTHOR " ]] && [[ "$IS_REPO_MAINTAINER" -ne 1 ]]; then
                COMMENT+=$'\n'"  - ‚ö†Ô∏è You are not the owner, a plugin maintainer, or a repository maintainer"
                PLUGIN_FAILED=1
              else
                COMMENT+=$'\n'"  - ‚úÖ Owner/maintainer/repo maintainer check passed"
              fi

              VERSION=$(jq -r '.version' "$PLUGIN_JSON")
              if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                COMMENT+=$'\n'"  - ‚úÖ Version semantic check passed ($VERSION)"
              else
                COMMENT+=$'\n'"  - ‚ö†Ô∏è Version not semantic ($VERSION)"
              fi

              # Version bump for existing plugin
              if git show origin/main:"$PLUGIN_JSON" > /dev/null 2>&1; then
                OLD_VERSION=$(git show origin/main:"$PLUGIN_JSON" | jq -r '.version')
                IFS='.' read -r OLD_MAJOR OLD_MINOR OLD_PATCH <<< "$OLD_VERSION"
                IFS='.' read -r NEW_MAJOR NEW_MINOR NEW_PATCH <<< "$VERSION"

                if (( NEW_MAJOR < OLD_MAJOR )) || \
                   (( NEW_MAJOR == OLD_MAJOR && NEW_MINOR < OLD_MINOR )) || \
                   (( NEW_MAJOR == OLD_MAJOR && NEW_MINOR == OLD_MINOR && NEW_PATCH <= OLD_PATCH )); then
                  COMMENT+=$'\n'"  - ‚ùå Version must be incremented from $OLD_VERSION ‚Üí $VERSION"
                  PLUGIN_FAILED=1
                else
                  COMMENT+=$'\n'"  - ‚úÖ Version bump OK ($OLD_VERSION ‚Üí $VERSION)"
                fi
              else
                # New plugin ‚Üí report version
                COMMENT+=$'\n'"  - ‚úÖ New plugin version ($VERSION)"
              fi
            fi

            # If table header/row were built, store the table for later appending at the bottom
            if [ -n "$TABLE_HEADER" ] && [ -n "$TABLE_ROW" ]; then
              PLUGIN_TABLES+=$'\n'"$TABLE_HEADER"
              PLUGIN_TABLES+=$'\n'"$TABLE_SEPARATOR"
              PLUGIN_TABLES+=$'\n'"$TABLE_ROW"
            fi

            if [ "$PLUGIN_FAILED" -eq 0 ]; then
              COMMENT+=$'\n'"  - ‚úÖ All checks passed for $plugin"
            else
              FAILED=1
            fi
          done

          # Global success summary
          if [ "$FAILED" -eq 0 ]; then
            COMMENT+=$'\n\n'"üéâ **All validation checks passed for this PR!**"
          fi

          # Append plugin.json table(s) right after the last plugin's results and global summary
          if [ -n "$PLUGIN_TABLES" ]; then
            COMMENT+=$'\n\n### Plugin Information\n'$'\n'"$PLUGIN_TABLES"
          fi


          # Write comment and FAILED status to files for later use
          printf '%s' "$COMMENT" > pr_comment.txt
          printf '%s' "$FAILED" > pr_failed.txt

      - name: Post PR comment
        if: always()
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          [ -f pr_comment.txt ] && gh pr comment $PR_NUMBER --body "$(cat pr_comment.txt)"
        continue-on-error: true

      - name: Fail workflow if any critical errors
        if: always()
        run: |
          FAILED=0
          [ -f pr_failed.txt ] && FAILED=$(cat pr_failed.txt)
          if [ "$FAILED" -ne 0 ]; then
            echo "::error::Plugin validation failed. See PR comment for details."
            exit 1
          fi